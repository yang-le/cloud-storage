# 7. Combinatorial Searching
## 7.1. Zeros and Ones
### 7.1.1. Boolean Basics
### 7.1.2. Boolean evaluation
### 7.1.3. Bitwise tricks and techniques
### 7.1.4. Binary decision diagrams
## 7.2. Generating all possibilities
### 7.2.1. Generating Basic Combinatorial Patterns
#### 7.2.1.1. Generating all n-tuples
#### 7.2.1.2. Generating all permutations
#### 7.2.1.3. Generating all combinations
#### 7.2.1.4. Generating all partitions
#### 7.2.1.5. Generating all set partitions
#### 7.2.1.6. Generating all trees
#### 7.2.1.7. History and further references
### 7.2.2. Backtrack Programming
#### 7.2.2.1. Dancing Links
#### 7.2.2.2. Satisfiability
#### 7.2.2.3. Constraint satisfaction
#### 7.2.2.4. Hamiltonian paths
#### 7.2.2.5. Cliques
#### 7.2.2.6. Covers
#### 7.2.2.7. Squares
#### 7.2.2.8. A potpourri of puzzles
#### 7.2.2.9. Estimating backtrack costs
### 7.2.3. Generating inequivalent patterns
## 7.3. Shortest paths
## 7.4. Graph algorithms
### 7.4.1. Components and traversal
### 7.4.2. Special classes of graphs
### 7.4.3. Expander graphs
### 7.4.4. Random graphs
## 7.5. Network algorithms
### 7.5.1. Distinct representatives
### 7.5.2. The assignment problem
### 7.5.3. Network flows
### 7.5.4. Optimum subtrees
### 7.5.5. Optimum matching
### 7.5.6. Optimum orderings
## 7.6. Independence theory
### 7.6.1. Independence structures
### 7.6.2. Efficient matroid algorithms
## 7.7. Discrete dynamic programming
## 7.8. Branch-and-bound techniques
## 7.9. Herculean tasks (aka NP-hard problems)
## 7.10. Near-optimization
# 8. Recursion
