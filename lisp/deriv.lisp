(defun variable? (x) (symbolp x))
(defun same-variable? (v1 v2)
  (and (variable? v1) (variable? v2) (eq v1 v2)))

(defun number? (x) (numberp x))
(defun =number? (exp num)
  (and (number? exp) (= exp num)))

(defun make-sum (a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (t (list '+ a1 a2))))

(defun make-product (m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (t (list '* m1 m2))))

(defun make-exponentiation (x1 x2)
  (cond ((=number? x2 0) 1)
        ((=number? x2 1) x1)
        ((and (number? x1) (number? x2)) (expt x1 x2))
        (t (list 'expt x1 x2))))

(defun sum? (x)
  (and (consp x) (eq (car x) '+)))
(defun addend (s) (cadr s))
(defun augend (s) (reduce #'make-sum (cddr s) :initial-value 0))

(defun product? (x)
  (and (consp x) (eq (car x) '*)))
(defun multiplier (p) (cadr p))
(defun multiplicand (p) (reduce #'make-product (cddr p) :initial-value 1))

(defun exponentiation? (x)
  (and (consp x) (eq (car x) 'expt)))
(defun base (x) (cadr x))
(defun power (x) (caddr x))

(defun deriv (exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product (power exp)
         (make-product (make-exponentiation (base exp)
                                            (- (power exp) 1))
                       (deriv (base exp) var))))
        (t (error "unknown expression type: DERIV"))))

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(expt x 2) 'x)
(deriv '(* x y (+ x 3)) 'x)
